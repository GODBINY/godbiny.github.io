---
title: 'Scheduled Annotation과 Spring batch의 특징'
slug: 'spring-boot/scheduled-annotation-and-batch'
date: '2025-09-04'
tags: ['Spring boot', Wiki']
draft: true 
summary: 'Scheduled Annotation과 batch, 각각 어느 때 쓰는지 정리'
---



개념 정리
요청 헤더의 Cache-Control
클라이언트가 “이번 요청/응답을 캐시에서 어떻게 처리해 줬으면 좋겠다”라고 중간 캐시(브라우저, 프록시 등)에게 요구하는 용도다.​
예를 들면 Cache-Control: no-cache, no-store, max-age=0, only-if-cached, min-fresh 같은 디렉티브를 요청에 실어 보낼 수 있다.​

응답 헤더의 Cache-Control
서버가 “이 응답은 이렇게 캐시해라”라고 클라이언트/프록시에게 지시하는 용도다.​
예를 들면 Cache-Control: max-age=3600, public, private, no-store, s-maxage 같은 값을 응답에 넣어 브라우저 캐시나 프록시 캐시의 저장·만료 정책을 결정한다.​

요청에 실리는 Cache-Control
클라이언트(브라우저)가 서버나 중간 캐시에게 “이번에는 캐시 쓰지 말고 새로 가져와”, “캐시에 있으면 그거만 쓰고, 네트워크는 타지 마” 같은 요구를 보낼 때 쓴다.​

대표 예시

Cache-Control: no-cache : 캐시된 응답이 있더라도, 사용 전에 꼭 원 서버에 재검증을 하라는 의미.​

Cache-Control: no-store : 민감한 정보라서 아예 저장하지 말라는 의미로, 브라우저/프록시에 남기지 말라는 요청이다.​

응답에 실리는 Cache-Control
서버가 응답과 함께 “이 응답은 n초 동안 재검증 없이 써도 된다”거나 “절대 저장하지 마라”처럼 정책을 내려보낼 때 쓴다.​

대표 예시

Cache-Control: max-age=3600 : 응답을 3600초 동안 신선한 것으로 보고, 그동안은 네트워크를 타지 않고 캐시에서 바로 꺼내 쓸 수 있다.​

Cache-Control: public / private : 공유 캐시(프록시, CDN 등)까지 저장해도 되는지, 아니면 개별 사용자 브라우저에만 저장해야 하는지를 나눈다.​

둘의 관계
Cache-Control은 “요청·응답 모두에 사용할 수 있는 일반 헤더”지만, 요청에 들어가는 디렉티브와 응답에 들어가는 디렉티브는 부분적으로 다르다.​

요청 헤더에 어떤 디렉티브를 보내더라도, 최종 권한은 응답 쪽 서버·캐시 정책에 있다. 서버가 응답을 no-store로 내려버리면, 이후부터는 캐시가 그 리소스를 저장하지 않는다.​
